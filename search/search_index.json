{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Despliegue de una aplicaci\u00f3n PHP con Nginx y MySQL usando Docker y Docker-compose Para la realizaci\u00f3n de esta pr\u00e1ctica, se parte de una estructura de directorios y archivos tal que: Creaci\u00f3n de un contenedor Nginx En primer lugar, comenzaremos modificando el archivo docker-compose.yml. Su contenido ser\u00e1: services: nginx: image: nginx:latest container_name: nginx-container ports: - 80:80 Con este contenido estamos indicando que se debe descargar una imagen de la \u00faltima versi\u00f3n de Nginx, crear un contenedor con ella y que este debe escuchar en el puerto 80 (que se corresponde con el 80 de nuestra m\u00e1quina). Para que se lleven a cabo estas acciones, ejecutamos: docker compose up -d Y para comprobar que el contenedor est\u00e1 corriendo: docker ps Al ejecutar estos comandos, si no ha habido ning\u00fan problema, debemos ver la siguiente respuesta: Y si accedemos al puerto 80 de la IP de la m\u00e1quina virtual desde el navegador de la m\u00e1quina anfitriona, veremos: Lo que significa que Nginx ya est\u00e1 funcionando sin problemas. Creaci\u00f3n de un contenedor PHP En primer lugar, modificaremos el archivo 'www/html/index.php'. Su contenido ser\u00e1: <!DOCTYPE html> <head> <title>\u00a1Hola mundo!</title> </head> <body> <h1>\u00a1Hola mundo!</h1> <p><?php echo 'Estamos corriendo PHP, version: ' . phpversion(); ?></p> </body> Ahora, para que Nginx pueda correr nuestra aplicaci\u00f3n PHP, modificaremos el archivo 'nginx/default.conf'. El contenido del archivo de configuraci\u00f3n ser\u00e1: server { listen 80 default_server; root /var/www/html; index index.html index.php; charset utf-8; location / { try_files $uri $uri/ /index.php?$query_string; } location = /favicon.ico { access_log off; log_not_found off; } location = /robots.txt { access_log off; log_not_found off; } access_log off; error_log /var/log/nginx/error.log error; sendfile off; client_max_body_size 100m; location ~ .php$ { fastcgi_split_path_info ^(.+.php)(/.+)$; fastcgi_pass php:9000; fastcgi_index index.php; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_intercept_errors off; fastcgi_buffer_size 16k; fastcgi_buffers 4 16k; } location ~ /.ht { deny all; } } Ahora modificaremos el archivo 'nginx/Dockerfile'. Su contenido ser\u00e1: FROM nginx:latest COPY ./default.conf /etc/nginx/conf.d/default.conf Y por \u00faltimo, volveremos a modificar el archivo 'docker-compose.yml' para que se descargue una imagen de PHP y se cree un contenedor a partir de ella. El nuevo contenido de este archivo ser\u00e1: services: nginx: build: ./nginx/ container_name: nginx-container ports: - 80:80 links: - php volumes: - ./www/html/:/var/www/html/ php: image: php:7.0-fpm container_name: php-container expose: - 9000 volumes: - ./www/html/:/var/www/html/ Volvemos a ejecutar los comandos: docker compose up -d docker ps El resultado es: Si ahora volvemos a acceder a nuestra m\u00e1quina virtual a trav\u00e9s del puerto 80 usando el navegador, podremos observar el contenido de la aplicaci\u00f3n PHP que hemos creado, servida por Nginx: Ya tenemos Nginx y PHP funcionando sin problemas. Creaci\u00f3n de un contenedor para Datos En el 'docker-compose.yml' est\u00e1 indicado que, tanto para Nginx como para PHP, hay que montar el directorio 'www/html'. Una manera m\u00e1s adecuada de hacerlo es crear un contenedor independiente para datos que se enlace con los contenedores ya existentes de Nginx y PHP. Para ello, volveremos a modificar el archivo 'docker-compose.yml'. Su nuevo contenido ser\u00e1: services: nginx: build: ./nginx/ container_name: nginx-container ports: - 80:80 links: - php volumes_from: - app-data php: image: php:7.0-fpm container_name: php-container expose: - 9000 volumes_from: - app-data app-data: image: php:7.0-fpm container_name: app-data-container volumes: - ./www/html/:/var/www/html/ command: \"true\" Volvemos a ejecutar: docker compose up -d docker ps -a El resultado debe ser: Creaci\u00f3n de un contenedor MySQL Por \u00faltimo, crearemos un contenedor con MySQL como BBDD para la aplicaci\u00f3n. En primer lugar, nos aseguraremos de que PHP podr\u00e1 comunicarse con MySQL editando el archivo 'php/Dockerfile' e indicaremos que se instale la extensi\u00f3n de PDO (que sirve en PHP para crear conexiones a BBDD y realizar consultas). El contenido del archivo ser\u00e1: FROM php:7.0-fpm RUN docker-php-ext-install pdo_mysql Tendremos que editar el archivo 'docker-compose.yml' por \u00faltima vez para que se generen contenedores que gestionen la BBDD MySQL as\u00ed como para relacionarlos con los contenedores que ya hemos creado (PHP, Nginx, app-data). El contenido final de 'docker-compose.yml' ser\u00e1: services: nginx: build: ./nginx/ container_name: nginx-container ports: - 80:80 links: - php volumes_from: - app-data php: build: ./php/ container_name: php-container expose: - 9000 links: - mysql volumes_from: - app-data app-data: image: php:7.0-fpm container_name: app-data-container volumes: - ./www/html/:/var/www/html/ command: \"true\" mysql: image: mysql:5.7 container_name: mysql-container volumes_from: - mysql-data environment: MYSQL_ROOT_PASSWORD: secret MYSQL_DATABASE: mydb MYSQL_USER: myuser MYSQL_PASSWORD: password mysql-data: image: mysql:5.7 container_name: mysql-data-container volumes: - /var/lib/mysql command: \"true\" Tambi\u00e9n modificaremos el archivo 'www/html/index.php' para que en \u00e9l se implementen conexi\u00f3n y consultas a la BBDD a trav\u00e9s de PDO. El contenido ser\u00e1: <!DOCTYPE html> <head> <title>\u00a1Hola mundo!</title> </head> <body> <h1>\u00a1Hola mundo!</h1> <p><?php echo 'Estamos corriendo PHP, version: ' . phpversion(); ?></p> <? $database =\"mydb\"; $user = \"myuser\"; $password = \"password\"; $host = \"mysql\"; $connection = new PDO(\"mysql:host={$host};dbname={$database};charset=utf8\", $user, $password); $query = $connection->query(\"SELECT TABLE_NAME FROM information_schema.TABLES WHERE TABLE_TYPE='BASE TABLE'\"); $tables = $query->fetchAll(PDO::FETCH_COLUMN); if (empty($tables)) { echo \"<p>No hay tablas en la base de datos \\\"{$database}\\\".</p>\"; } else { echo \"<p>La base de datos \\\"{$database}\\\" tiene las siguientes tablas:</p>\"; echo \"<ul>\"; foreach ($tables as $table) { echo \"<li>{$table}</li>\"; } echo \"</ul>\"; } ?> </body> </html> Levantamos los contenedores de la aplicaci\u00f3n ejecutando de nuevo: docker compose up -d docker ps -a Que debe devolver una respuesta como esta: Y si volvemos a acceder desde nuestro navegador a la aplicaci\u00f3n: Que nos responda que \"No hay tablas en la base de datos...\" no es un error; ahora s\u00f3lo estamos comprobando que los contenedores se han creado y que est\u00e1n enlazados correctamente. Para que se acceda a la BBDD y se muestren correctamente las tablas de la BBDD ser\u00e1 necesario hacer una peque\u00f1a modificaci\u00f3n. Verificaci\u00f3n de la conexi\u00f3n a la BBDD El motivo por el que las tablas no est\u00e1n visibles en la aplicaci\u00f3n es que la conexi\u00f3n que estamos realizando desde 'www/html/index.php' utiliza los datos de un usuario sin privilegios para acceder a las tablas de la BBDD. Para acceder con un usuario con permisos y que podamos comprobar que la conexi\u00f3n a la BBDD funciona y devuelve datos correctos, es necesario, en 'www/html/index.php', cambiar los valores de dos variables: $user = \"root\"; $password = \"secret\"; Con este peque\u00f1o cambio, si accedemos de nuevo a la aplicaci\u00f3n desde el navegador, podremos ver los datos almacenados en la BBDD (en este caso, estamos consultando los nombres de las tablas existentes):","title":"Despliegue de una aplicaci\u00f3n PHP con Nginx y MySQL usando Docker y Docker-compose"},{"location":"#despliegue-de-una-aplicacion-php-con-nginx-y-mysql-usando-docker-y-docker-compose","text":"Para la realizaci\u00f3n de esta pr\u00e1ctica, se parte de una estructura de directorios y archivos tal que:","title":"Despliegue de una aplicaci\u00f3n PHP con Nginx y MySQL usando Docker y Docker-compose"},{"location":"#creacion-de-un-contenedor-nginx","text":"En primer lugar, comenzaremos modificando el archivo docker-compose.yml. Su contenido ser\u00e1: services: nginx: image: nginx:latest container_name: nginx-container ports: - 80:80 Con este contenido estamos indicando que se debe descargar una imagen de la \u00faltima versi\u00f3n de Nginx, crear un contenedor con ella y que este debe escuchar en el puerto 80 (que se corresponde con el 80 de nuestra m\u00e1quina). Para que se lleven a cabo estas acciones, ejecutamos: docker compose up -d Y para comprobar que el contenedor est\u00e1 corriendo: docker ps Al ejecutar estos comandos, si no ha habido ning\u00fan problema, debemos ver la siguiente respuesta: Y si accedemos al puerto 80 de la IP de la m\u00e1quina virtual desde el navegador de la m\u00e1quina anfitriona, veremos: Lo que significa que Nginx ya est\u00e1 funcionando sin problemas.","title":"Creaci\u00f3n de un contenedor Nginx"},{"location":"#creacion-de-un-contenedor-php","text":"En primer lugar, modificaremos el archivo 'www/html/index.php'. Su contenido ser\u00e1: <!DOCTYPE html> <head> <title>\u00a1Hola mundo!</title> </head> <body> <h1>\u00a1Hola mundo!</h1> <p><?php echo 'Estamos corriendo PHP, version: ' . phpversion(); ?></p> </body> Ahora, para que Nginx pueda correr nuestra aplicaci\u00f3n PHP, modificaremos el archivo 'nginx/default.conf'. El contenido del archivo de configuraci\u00f3n ser\u00e1: server { listen 80 default_server; root /var/www/html; index index.html index.php; charset utf-8; location / { try_files $uri $uri/ /index.php?$query_string; } location = /favicon.ico { access_log off; log_not_found off; } location = /robots.txt { access_log off; log_not_found off; } access_log off; error_log /var/log/nginx/error.log error; sendfile off; client_max_body_size 100m; location ~ .php$ { fastcgi_split_path_info ^(.+.php)(/.+)$; fastcgi_pass php:9000; fastcgi_index index.php; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_intercept_errors off; fastcgi_buffer_size 16k; fastcgi_buffers 4 16k; } location ~ /.ht { deny all; } } Ahora modificaremos el archivo 'nginx/Dockerfile'. Su contenido ser\u00e1: FROM nginx:latest COPY ./default.conf /etc/nginx/conf.d/default.conf Y por \u00faltimo, volveremos a modificar el archivo 'docker-compose.yml' para que se descargue una imagen de PHP y se cree un contenedor a partir de ella. El nuevo contenido de este archivo ser\u00e1: services: nginx: build: ./nginx/ container_name: nginx-container ports: - 80:80 links: - php volumes: - ./www/html/:/var/www/html/ php: image: php:7.0-fpm container_name: php-container expose: - 9000 volumes: - ./www/html/:/var/www/html/ Volvemos a ejecutar los comandos: docker compose up -d docker ps El resultado es: Si ahora volvemos a acceder a nuestra m\u00e1quina virtual a trav\u00e9s del puerto 80 usando el navegador, podremos observar el contenido de la aplicaci\u00f3n PHP que hemos creado, servida por Nginx: Ya tenemos Nginx y PHP funcionando sin problemas.","title":"Creaci\u00f3n de un contenedor PHP"},{"location":"#creacion-de-un-contenedor-para-datos","text":"En el 'docker-compose.yml' est\u00e1 indicado que, tanto para Nginx como para PHP, hay que montar el directorio 'www/html'. Una manera m\u00e1s adecuada de hacerlo es crear un contenedor independiente para datos que se enlace con los contenedores ya existentes de Nginx y PHP. Para ello, volveremos a modificar el archivo 'docker-compose.yml'. Su nuevo contenido ser\u00e1: services: nginx: build: ./nginx/ container_name: nginx-container ports: - 80:80 links: - php volumes_from: - app-data php: image: php:7.0-fpm container_name: php-container expose: - 9000 volumes_from: - app-data app-data: image: php:7.0-fpm container_name: app-data-container volumes: - ./www/html/:/var/www/html/ command: \"true\" Volvemos a ejecutar: docker compose up -d docker ps -a El resultado debe ser:","title":"Creaci\u00f3n de un contenedor para Datos"},{"location":"#creacion-de-un-contenedor-mysql","text":"Por \u00faltimo, crearemos un contenedor con MySQL como BBDD para la aplicaci\u00f3n. En primer lugar, nos aseguraremos de que PHP podr\u00e1 comunicarse con MySQL editando el archivo 'php/Dockerfile' e indicaremos que se instale la extensi\u00f3n de PDO (que sirve en PHP para crear conexiones a BBDD y realizar consultas). El contenido del archivo ser\u00e1: FROM php:7.0-fpm RUN docker-php-ext-install pdo_mysql Tendremos que editar el archivo 'docker-compose.yml' por \u00faltima vez para que se generen contenedores que gestionen la BBDD MySQL as\u00ed como para relacionarlos con los contenedores que ya hemos creado (PHP, Nginx, app-data). El contenido final de 'docker-compose.yml' ser\u00e1: services: nginx: build: ./nginx/ container_name: nginx-container ports: - 80:80 links: - php volumes_from: - app-data php: build: ./php/ container_name: php-container expose: - 9000 links: - mysql volumes_from: - app-data app-data: image: php:7.0-fpm container_name: app-data-container volumes: - ./www/html/:/var/www/html/ command: \"true\" mysql: image: mysql:5.7 container_name: mysql-container volumes_from: - mysql-data environment: MYSQL_ROOT_PASSWORD: secret MYSQL_DATABASE: mydb MYSQL_USER: myuser MYSQL_PASSWORD: password mysql-data: image: mysql:5.7 container_name: mysql-data-container volumes: - /var/lib/mysql command: \"true\" Tambi\u00e9n modificaremos el archivo 'www/html/index.php' para que en \u00e9l se implementen conexi\u00f3n y consultas a la BBDD a trav\u00e9s de PDO. El contenido ser\u00e1: <!DOCTYPE html> <head> <title>\u00a1Hola mundo!</title> </head> <body> <h1>\u00a1Hola mundo!</h1> <p><?php echo 'Estamos corriendo PHP, version: ' . phpversion(); ?></p> <? $database =\"mydb\"; $user = \"myuser\"; $password = \"password\"; $host = \"mysql\"; $connection = new PDO(\"mysql:host={$host};dbname={$database};charset=utf8\", $user, $password); $query = $connection->query(\"SELECT TABLE_NAME FROM information_schema.TABLES WHERE TABLE_TYPE='BASE TABLE'\"); $tables = $query->fetchAll(PDO::FETCH_COLUMN); if (empty($tables)) { echo \"<p>No hay tablas en la base de datos \\\"{$database}\\\".</p>\"; } else { echo \"<p>La base de datos \\\"{$database}\\\" tiene las siguientes tablas:</p>\"; echo \"<ul>\"; foreach ($tables as $table) { echo \"<li>{$table}</li>\"; } echo \"</ul>\"; } ?> </body> </html> Levantamos los contenedores de la aplicaci\u00f3n ejecutando de nuevo: docker compose up -d docker ps -a Que debe devolver una respuesta como esta: Y si volvemos a acceder desde nuestro navegador a la aplicaci\u00f3n: Que nos responda que \"No hay tablas en la base de datos...\" no es un error; ahora s\u00f3lo estamos comprobando que los contenedores se han creado y que est\u00e1n enlazados correctamente. Para que se acceda a la BBDD y se muestren correctamente las tablas de la BBDD ser\u00e1 necesario hacer una peque\u00f1a modificaci\u00f3n.","title":"Creaci\u00f3n de un contenedor MySQL"},{"location":"#verificacion-de-la-conexion-a-la-bbdd","text":"El motivo por el que las tablas no est\u00e1n visibles en la aplicaci\u00f3n es que la conexi\u00f3n que estamos realizando desde 'www/html/index.php' utiliza los datos de un usuario sin privilegios para acceder a las tablas de la BBDD. Para acceder con un usuario con permisos y que podamos comprobar que la conexi\u00f3n a la BBDD funciona y devuelve datos correctos, es necesario, en 'www/html/index.php', cambiar los valores de dos variables: $user = \"root\"; $password = \"secret\"; Con este peque\u00f1o cambio, si accedemos de nuevo a la aplicaci\u00f3n desde el navegador, podremos ver los datos almacenados en la BBDD (en este caso, estamos consultando los nombres de las tablas existentes):","title":"Verificaci\u00f3n de la conexi\u00f3n a la BBDD"}]}